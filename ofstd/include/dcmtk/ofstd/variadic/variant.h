/*
** DO NOT EDIT THIS FILE !!!
** It was generated automatically by:
**
**   User: jan
**   Host: caesar
**   Date: 2017-11-16 12:31:32
**   Prog: /home/jan/scripts/make_variadic.sh
**
** Purpose:
**   Emulating variadic template parameters support for OFvariant with generated
**   code.
*/
#ifndef VARIADIC_VARIANT_H
#define VARIADIC_VARIANT_H

#include "dcmtk/config/osconfig.h"    /* make sure OS specific configuration is included first */

#include "dcmtk/ofstd/variadic/helpers.h"
#include "dcmtk/ofstd/ofutil.h"
#include "dcmtk/ofstd/ofdiag.h"

// We hide all this from doxygen, because it would only scare sane people
// (and it is not needed for understanding how to use OFvariant).
#ifndef DOXYGEN

// Template recursively overload constructor and assignment operator for the
// different alternatives of the variant (used in the template constructor/
// assignment members).
template<size_t Index,typename T0=OFvariadic_nil,typename T1=OFvariadic_nil,typename T2=OFvariadic_nil,typename T3=OFvariadic_nil,typename T4=OFvariadic_nil,typename T5=OFvariadic_nil,typename T6=OFvariadic_nil,typename T7=OFvariadic_nil,typename T8=OFvariadic_nil,typename T9=OFvariadic_nil,typename T10=OFvariadic_nil,typename T11=OFvariadic_nil,typename T12=OFvariadic_nil,typename T13=OFvariadic_nil,typename T14=OFvariadic_nil,typename T15=OFvariadic_nil,typename T16=OFvariadic_nil,typename T17=OFvariadic_nil,typename T18=OFvariadic_nil,typename T19=OFvariadic_nil,typename T20=OFvariadic_nil,typename T21=OFvariadic_nil,typename T22=OFvariadic_nil,typename T23=OFvariadic_nil,typename T24=OFvariadic_nil,typename T25=OFvariadic_nil,typename T26=OFvariadic_nil,typename T27=OFvariadic_nil,typename T28=OFvariadic_nil,typename T29=OFvariadic_nil,typename T30=OFvariadic_nil,typename T31=OFvariadic_nil,typename T32=OFvariadic_nil,typename T33=OFvariadic_nil,typename T34=OFvariadic_nil,typename T35=OFvariadic_nil,typename T36=OFvariadic_nil,typename T37=OFvariadic_nil,typename T38=OFvariadic_nil,typename T39=OFvariadic_nil,typename T40=OFvariadic_nil,typename T41=OFvariadic_nil,typename T42=OFvariadic_nil,typename T43=OFvariadic_nil,typename T44=OFvariadic_nil,typename T45=OFvariadic_nil,typename T46=OFvariadic_nil,typename T47=OFvariadic_nil,typename T48=OFvariadic_nil,typename T49=OFvariadic_nil>
struct OFvariant_overload
: OFvariant_overload<Index+1,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>
{
    // Let the inherited methods take part in overload resolution
    using OFvariant_overload<Index+1,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::copy_constructor;
    using OFvariant_overload<Index+1,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::move_constructor;
    using OFvariant_overload<Index+1,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::copy_assignment;
    using OFvariant_overload<Index+1,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::move_assignment;
    static Uint16 test_accepts( T0 );
    static Uint8 test_accepts( ... );

#ifdef OFalign
    static size_t copy_constructor( void* content, const T0& t0 )
    {
        new (content) T0( t0 );
#else
    static size_t copy_constructor( void*& content, const T0& t0 )
    {
        content = new T0( t0 );
#endif
        return Index;
    }

#ifdef OFalign
    static size_t move_constructor( void* content, OFrvalue_ref(T0) t0 )
    {
        new (content) T0( t0 );
#else
    static size_t move_constructor( void*& content, OFrvalue_ref(T0) t0 )
    {
        content = new T0( t0 );
#endif
        return Index;
    }

    static bool copy_assignment( size_t index, void* content, const T0& t0 )
    {
        if( index == Index )
        {
            *static_cast<T0*>( content ) = t0;
            return true;
        }
        return false;
    }

    static bool move_assignment( size_t index, void* content, OFrvalue_ref(T0) t0 )
    {
        if( index == Index )
        {
            *static_cast<T0*>( content ) = t0;
            return true;
        }
        return false;
    }

// This code is executed at compile-time, the warnings therefore make
// absolutely no sense (only Visual Studio emits them ;-).
// Converting an integer to a boolean value at compile-time won't have any
// performance ramifications and type conversion will be checked elsewhere,
// not when checking if an overload *potentially exists*.
#include DCMTK_DIAGNOSTIC_PUSH
#include DCMTK_DIAGNOSTIC_IGNORE_IMPLICIT_CONVERSION
#include DCMTK_DIAGNOSTIC_IGNORE_VISUAL_STUDIO_PERFORMANCE_WARNING
    template<typename T>
    struct accepts : OFintegral_constant<OFBool,sizeof(test_accepts(*OFstatic_cast(T*,OFnullptr)))==2 || OFvariant_overload<Index+1,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::template accepts<T>::value> {};
#include DCMTK_DIAGNOSTIC_POP
};

// Template recursion end, declares both functions with incompatible
// signatures so that the 'using' statements work but the functions
// do not effectively take part in the overload resolution.
template<size_t Index>
struct OFvariant_overload<Index>
{
    static void copy_constructor();
    static void move_constructor();
    static void copy_assignment();
    static void move_assignment();
    template<typename T>
    struct accepts : OFfalse_type {};
};

// Creates a function pointer lookup table to select a function for the
// currently contained alternative based on the stored index.
// This is not really magic, the syntax will hurt your eyes though!
template<typename Invoker,typename T0=OFvariadic_nil,typename T1=OFvariadic_nil,typename T2=OFvariadic_nil,typename T3=OFvariadic_nil,typename T4=OFvariadic_nil,typename T5=OFvariadic_nil,typename T6=OFvariadic_nil,typename T7=OFvariadic_nil,typename T8=OFvariadic_nil,typename T9=OFvariadic_nil,typename T10=OFvariadic_nil,typename T11=OFvariadic_nil,typename T12=OFvariadic_nil,typename T13=OFvariadic_nil,typename T14=OFvariadic_nil,typename T15=OFvariadic_nil,typename T16=OFvariadic_nil,typename T17=OFvariadic_nil,typename T18=OFvariadic_nil,typename T19=OFvariadic_nil,typename T20=OFvariadic_nil,typename T21=OFvariadic_nil,typename T22=OFvariadic_nil,typename T23=OFvariadic_nil,typename T24=OFvariadic_nil,typename T25=OFvariadic_nil,typename T26=OFvariadic_nil,typename T27=OFvariadic_nil,typename T28=OFvariadic_nil,typename T29=OFvariadic_nil,typename T30=OFvariadic_nil,typename T31=OFvariadic_nil,typename T32=OFvariadic_nil,typename T33=OFvariadic_nil,typename T34=OFvariadic_nil,typename T35=OFvariadic_nil,typename T36=OFvariadic_nil,typename T37=OFvariadic_nil,typename T38=OFvariadic_nil,typename T39=OFvariadic_nil,typename T40=OFvariadic_nil,typename T41=OFvariadic_nil,typename T42=OFvariadic_nil,typename T43=OFvariadic_nil,typename T44=OFvariadic_nil,typename T45=OFvariadic_nil,typename T46=OFvariadic_nil,typename T47=OFvariadic_nil,typename T48=OFvariadic_nil,typename T49=OFvariadic_nil>
class OFvariant_invoke_t
{
public:
    OFvariant_invoke_t()
    {
        // Template-recursively assign the function pointers to the fitting
        // position inside the function pointer array. This will most likely
        // be inlined by the compiler (it is tail recursive) and therefore
        // not hurt the performance.
        init<0>();
    }

// suppress spurious gcc warnings about array subscript issues in 
// OFvariant_destroy_invoker issued by gcc 11 and newer
#include DCMTK_DIAGNOSTIC_PUSH
#include DCMTK_DIAGNOSTIC_IGNORE_ARRAY_BOUNDS
    OFTypename Invoker::return_type operator()( size_t index, void* content, const Invoker& invoker = Invoker() )
    {
        // Select the fitting function pointer based on the index and call it with
        // the given pointer to the current contents.
        return (invoker.*m_Alternatives[index])( content );
    }
#include DCMTK_DIAGNOSTIC_POP

private:

    // This is the recursion step for the Init template, it initializes the current
    // function pointer and recurses to the Init template for the next index.
    template<size_t Index>
    OFTypename OFenable_if<(Index < OFvariadic_parameter_pack_sizeof<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::value)>::type init()
    {
        m_Alternatives[Index] = &Invoker::template invoke<OFTypename OFvariadic_nth_type<Index,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::type>;
        init<Index+1>();
    }

    // this is the specialization for the base of the recursion, doing nothing for the
    // N+1th alternative, effectively stopping the recursion.
    template<size_t Index>
    OFTypename OFenable_if<(Index >= OFvariadic_parameter_pack_sizeof<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::value)>::type init()
    {

    }

    // the actual function pointer array
    OFTypename Invoker::return_type (Invoker::*m_Alternatives[OFvariadic_parameter_pack_sizeof<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::value])(void*) const;
};

// A helper template function for initializing and using a function
// pointer lookup table as dispatcher for variant visitation etc.
template<typename Invoker,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9,typename T10,typename T11,typename T12,typename T13,typename T14,typename T15,typename T16,typename T17,typename T18,typename T19,typename T20,typename T21,typename T22,typename T23,typename T24,typename T25,typename T26,typename T27,typename T28,typename T29,typename T30,typename T31,typename T32,typename T33,typename T34,typename T35,typename T36,typename T37,typename T38,typename T39,typename T40,typename T41,typename T42,typename T43,typename T44,typename T45,typename T46,typename T47,typename T48,typename T49>
OFTypename Invoker::return_type OFvariant_invoke( size_t index, void* content, const Invoker& invoker = Invoker() )
{
    // this may be a race condition in older compilers, which is no
    // problem since the copied addresses of the functions are always
    // the same.
    static OFvariant_invoke_t<Invoker,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49> invocation_table;
    return invocation_table( index, content, invoker );
}

// A functor that does copy construction from another variant
// object.
struct OFvariant_copy_construct_invoker
{
    typedef void return_type;

#ifdef OFalign
    OFvariant_copy_construct_invoker( void* content )
    : m_Content( content )
#else
    OFvariant_copy_construct_invoker( void*& content )
    : m_pContent( content )
#endif
    {

    }

    template<typename T>
    void invoke( void* content ) const
    {
#ifdef OFalign
        new (m_Content) T( *static_cast<const T*>( content ) );
#else
        m_pContent = new T( *static_cast<const T*>( content ) );
#endif
    }

#ifdef OFalign
    void* m_Content;
#else
    void*& m_pContent;
#endif
};

// A functor that does move construction from another variant
// object.
struct OFvariant_move_construct_invoker
{
    typedef void return_type;

#ifdef OFalign
    OFvariant_move_construct_invoker( void* content )
    : m_Content( content )
#else
    OFvariant_move_construct_invoker( void*& content )
    : m_pContent( content )
#endif
    {

    }

    template<typename T>
    void invoke( void* content ) const
    {
#ifdef OFalign
        new (m_Content) T( OFmove( *static_cast<T*>( content ) ) );
#else
        m_pContent = new T( OFmove( *static_cast<T*>( content ) ) );
#endif
    }

#ifdef OFalign
    void* m_Content;
#else
    void*& m_pContent;
#endif
};

// A functor that copy assigns the contents of another variant
// object that contains the same alternative (regarding the type).
struct OFvariant_copy_assign_invoker
{
    typedef void return_type;

    OFvariant_copy_assign_invoker( void* content )
    : m_Content( content )
    {

    }

    template<typename T>
    void invoke( void* rhs ) const
    {
        *static_cast<T*>( m_Content ) = *static_cast<const T*>( rhs );
    }

    void* m_Content;
};

// A functor that move assigns the contents of another variant
// object that contains the same alternative (regarding the type).
struct OFvariant_move_assign_invoker
{
    typedef void return_type;

    OFvariant_move_assign_invoker( void* content )
    : m_Content( content )
    {

    }

    template<typename T>
    void invoke( void* rhs ) const
    {
        *static_cast<T*>( m_Content ) = OFmove( *static_cast<T*>( rhs ) );
    }

    void* m_Content;
};

// A functor that destroys the contained object.
struct OFvariant_destroy_invoker
{
    typedef void return_type;

#include DCMTK_DIAGNOSTIC_PUSH
#include DCMTK_DIAGNOSTIC_IGNORE_UNREFERENCED_FORMAL_PARAMETER
    template<typename T>
    void invoke( void* content ) const
    {
#ifdef OFalign
        static_cast<T*>( content )->~T();
#else
        delete static_cast<T*>( content );
#endif
    }
#include DCMTK_DIAGNOSTIC_POP

};

// A functor that invokes the given functor, seriously!
template<typename ReturnType,typename FN>
struct OFvariant_visit_invoker
{
    typedef ReturnType return_type;

    OFvariant_visit_invoker( FN& fn )
    : m_Fn( fn )
    {

    }

    template<typename T>
    ReturnType invoke( void* content ) const
    {
        return m_Fn( *static_cast<T*>( content ) );
    }

    FN& m_Fn;
};

// The same as above, but for the const case.
template<typename ReturnType,typename FN>
struct OFvariant_const_visit_invoker
{
    typedef ReturnType return_type;

    OFvariant_const_visit_invoker( FN& fn )
    : m_Fn( fn )
    {

    }

    template<typename T>
    ReturnType invoke( void* content ) const
    {
        return m_Fn( *static_cast<const T*>( content ) );
    }

    FN& m_Fn;
};

// The actual variant implementation. Don't mess with this, look
// at the doxygen API description instead.
template<typename T0=OFvariadic_nil,typename T1=OFvariadic_nil,typename T2=OFvariadic_nil,typename T3=OFvariadic_nil,typename T4=OFvariadic_nil,typename T5=OFvariadic_nil,typename T6=OFvariadic_nil,typename T7=OFvariadic_nil,typename T8=OFvariadic_nil,typename T9=OFvariadic_nil,typename T10=OFvariadic_nil,typename T11=OFvariadic_nil,typename T12=OFvariadic_nil,typename T13=OFvariadic_nil,typename T14=OFvariadic_nil,typename T15=OFvariadic_nil,typename T16=OFvariadic_nil,typename T17=OFvariadic_nil,typename T18=OFvariadic_nil,typename T19=OFvariadic_nil,typename T20=OFvariadic_nil,typename T21=OFvariadic_nil,typename T22=OFvariadic_nil,typename T23=OFvariadic_nil,typename T24=OFvariadic_nil,typename T25=OFvariadic_nil,typename T26=OFvariadic_nil,typename T27=OFvariadic_nil,typename T28=OFvariadic_nil,typename T29=OFvariadic_nil,typename T30=OFvariadic_nil,typename T31=OFvariadic_nil,typename T32=OFvariadic_nil,typename T33=OFvariadic_nil,typename T34=OFvariadic_nil,typename T35=OFvariadic_nil,typename T36=OFvariadic_nil,typename T37=OFvariadic_nil,typename T38=OFvariadic_nil,typename T39=OFvariadic_nil,typename T40=OFvariadic_nil,typename T41=OFvariadic_nil,typename T42=OFvariadic_nil,typename T43=OFvariadic_nil,typename T44=OFvariadic_nil,typename T45=OFvariadic_nil,typename T46=OFvariadic_nil,typename T47=OFvariadic_nil,typename T48=OFvariadic_nil,typename T49=OFvariadic_nil>
class OFvariant
{
public:
    // typedef for old compilers that do not define the type 'OFvariant' in derived classes
    typedef OFvariant variant;

    OFvariant()
#ifdef OFalign
    : m_Content()
#else
    : m_pContent( new T0 )
#endif
    , m_Index( 0 )
    {
#ifdef OFalign
        new (content()) T0;
#endif
    }

    template<typename T>
    OFvariant( const T& t, OFTypename OFenable_if<OFvariant_overload<0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::template accepts<T>::value,int>::type = 0 )
#ifdef OFalign
    : m_Content()
#else
    : m_pContent()
#endif
    , m_Index( OFvariant_overload<0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::copy_constructor( content(), t ) )
    {

    }

    template<typename T>
    OFvariant( OFrvalue_ref(T) t, OFTypename OFenable_if<OFvariant_overload<0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::template accepts<OFrvalue<T> >::value,int>::type = 0 )
#ifdef OFalign
    : m_Content()
#else
    : m_pContent()
#endif
    , m_Index( OFvariant_overload<0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::move_constructor( content(), t ) )
    {

    }

    OFvariant( const OFvariant& rhs )
#ifdef OFalign
    : m_Content()
#else
    : m_pContent()
#endif
    , m_Index( rhs.index() )
    {
        copy_construct( rhs.content() );
    }

    OFvariant( OFrvalue_ref(OFvariant) rhs )
#ifdef OFalign
    : m_Content()
#else
    : m_pContent()
#endif
    , m_Index( rhs.index() )
    {
        move_construct( rhs.content() );
    }

    template<typename T>
    OFTypename OFenable_if<OFvariant_overload<0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::template accepts<T>::value,OFvariant>::type& operator=( const T& t )
    {
        // Either assign 't' if the contained alternative fits.
        if( !OFvariant_overload<0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::copy_assignment( index(), content(), t ) )
        {
            // Or destroy the contained alternative and construct
            // a new one, based on 't'.
            destroy();
            m_Index = OFvariant_overload<0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::copy_constructor( content(), t );
        }
        return *this;
    }

    template<typename T>
    OFTypename OFenable_if<OFvariant_overload<0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::template accepts<OFrvalue<T> >::value,OFvariant>::type& operator=( OFrvalue_ref(T) t )
    {
        // Either assign 't' if the contained alternative fits.
        if( !OFvariant_overload<0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::move_assignment( index(), content(), t ) )
        {
            // Or destroy the contained alternative and construct
            // a new one, based on 't'.
            destroy();
            m_Index = OFvariant_overload<0,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::move_constructor( content(), t );
        }
        return *this;
    }

    OFvariant& operator=( const OFvariant& rhs )
    {
        if( this != &rhs )
        {
            // Do 'native' assignment if both variants contain
            // the same alternative
            if( m_Index == rhs.m_Index )
            {
                OFvariant_invoke<OFvariant_copy_assign_invoker,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>
                (
                    m_Index,
                    rhs.content(),
                    OFvariant_copy_assign_invoker( content() )
                );
            }
            else
            {
                // Destroy the contents and copy construct a new
                // one
                destroy();
                m_Index = rhs.m_Index;
                copy_construct( rhs.content() );
            }
        }
        return *this;
    }

    OFvariant& operator=( OFrvalue_ref(OFvariant) rhs )
    {
        if( this != &rhs )
        {
            // Do 'native' assignment if both variants contain
            // the same alternative
            if( m_Index == rhs.m_Index )
            {
                OFvariant_invoke<OFvariant_move_assign_invoker,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>
                (
                    m_Index,
                    rhs.content(),
                    OFvariant_move_assign_invoker( content() )
                );
            }
            else
            {
                // Destroy the contents and copy construct a new
                // one
                destroy();
                m_Index = rhs.m_Index;
                move_construct( rhs.content() );
            }
        }
        return *this;
    }

    ~OFvariant()
    {
        // Destroy the contained object
        destroy();
    }

    size_t index() const
    {
        // Well, this is easy
        return m_Index;
    }

private:
    // Friend declarations for visitation and get<>.
    template<typename T,typename X0,typename X1,typename X2,typename X3,typename X4,typename X5,typename X6,typename X7,typename X8,typename X9,typename X10,typename X11,typename X12,typename X13,typename X14,typename X15,typename X16,typename X17,typename X18,typename X19,typename X20,typename X21,typename X22,typename X23,typename X24,typename X25,typename X26,typename X27,typename X28,typename X29,typename X30,typename X31,typename X32,typename X33,typename X34,typename X35,typename X36,typename X37,typename X38,typename X39,typename X40,typename X41,typename X42,typename X43,typename X44,typename X45,typename X46,typename X47,typename X48,typename X49>
    friend T* OFget( OFvariant<X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,X18,X19,X20,X21,X22,X23,X24,X25,X26,X27,X28,X29,X30,X31,X32,X33,X34,X35,X36,X37,X38,X39,X40,X41,X42,X43,X44,X45,X46,X47,X48,X49>* );
    template<typename T,typename X0,typename X1,typename X2,typename X3,typename X4,typename X5,typename X6,typename X7,typename X8,typename X9,typename X10,typename X11,typename X12,typename X13,typename X14,typename X15,typename X16,typename X17,typename X18,typename X19,typename X20,typename X21,typename X22,typename X23,typename X24,typename X25,typename X26,typename X27,typename X28,typename X29,typename X30,typename X31,typename X32,typename X33,typename X34,typename X35,typename X36,typename X37,typename X38,typename X39,typename X40,typename X41,typename X42,typename X43,typename X44,typename X45,typename X46,typename X47,typename X48,typename X49>
    friend const T* OFget( const OFvariant<X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,X18,X19,X20,X21,X22,X23,X24,X25,X26,X27,X28,X29,X30,X31,X32,X33,X34,X35,X36,X37,X38,X39,X40,X41,X42,X43,X44,X45,X46,X47,X48,X49>* );
    template<typename ReturnType,typename FN,typename X0,typename X1,typename X2,typename X3,typename X4,typename X5,typename X6,typename X7,typename X8,typename X9,typename X10,typename X11,typename X12,typename X13,typename X14,typename X15,typename X16,typename X17,typename X18,typename X19,typename X20,typename X21,typename X22,typename X23,typename X24,typename X25,typename X26,typename X27,typename X28,typename X29,typename X30,typename X31,typename X32,typename X33,typename X34,typename X35,typename X36,typename X37,typename X38,typename X39,typename X40,typename X41,typename X42,typename X43,typename X44,typename X45,typename X46,typename X47,typename X48,typename X49>
    friend ReturnType OFvisit( FN, OFvariant<X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,X18,X19,X20,X21,X22,X23,X24,X25,X26,X27,X28,X29,X30,X31,X32,X33,X34,X35,X36,X37,X38,X39,X40,X41,X42,X43,X44,X45,X46,X47,X48,X49>& );
    template<typename ReturnType,typename FN,typename X0,typename X1,typename X2,typename X3,typename X4,typename X5,typename X6,typename X7,typename X8,typename X9,typename X10,typename X11,typename X12,typename X13,typename X14,typename X15,typename X16,typename X17,typename X18,typename X19,typename X20,typename X21,typename X22,typename X23,typename X24,typename X25,typename X26,typename X27,typename X28,typename X29,typename X30,typename X31,typename X32,typename X33,typename X34,typename X35,typename X36,typename X37,typename X38,typename X39,typename X40,typename X41,typename X42,typename X43,typename X44,typename X45,typename X46,typename X47,typename X48,typename X49>
    friend ReturnType OFvisit( FN, const OFvariant<X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,X18,X19,X20,X21,X22,X23,X24,X25,X26,X27,X28,X29,X30,X31,X32,X33,X34,X35,X36,X37,X38,X39,X40,X41,X42,X43,X44,X45,X46,X47,X48,X49>& );

    // Invoke copy construction
    void copy_construct( void* rhs )
    {
        OFvariant_invoke<OFvariant_copy_construct_invoker,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>
        (
            m_Index,
            rhs,
            OFvariant_copy_construct_invoker( content() )
        );
    }

    // Invoke move construction
    void move_construct( void* rhs )
    {
        OFvariant_invoke<OFvariant_move_construct_invoker,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>
        (
            m_Index,
            rhs,
            OFvariant_move_construct_invoker( content() )
        );
    }

    // Invoke destructor
    void destroy()
    {
        OFvariant_invoke<OFvariant_destroy_invoker,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>( m_Index, content() );
    }

#ifdef OFalign
    // Allocate content with alignment.
    typedef OFTypename OFfold<OFmax_sizeof,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::type max_sizeof_type;
    typedef OFTypename OFfold<OFmax_alignof,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::type max_alignof_type;
    void* content() const { return m_Content; }
    mutable OFalign_typename(Uint8[max_sizeof_type::value],max_alignof_type::value) m_Content;
#else
    // Allocate content on the heap.
    void*& content() const { return OFconst_cast(void*&,m_pContent); }
    void* m_pContent;
#endif
    size_t m_Index;
};

// Actual implementation of get<> by type.
template<typename T,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9,typename T10,typename T11,typename T12,typename T13,typename T14,typename T15,typename T16,typename T17,typename T18,typename T19,typename T20,typename T21,typename T22,typename T23,typename T24,typename T25,typename T26,typename T27,typename T28,typename T29,typename T30,typename T31,typename T32,typename T33,typename T34,typename T35,typename T36,typename T37,typename T38,typename T39,typename T40,typename T41,typename T42,typename T43,typename T44,typename T45,typename T46,typename T47,typename T48,typename T49>
T* OFget( OFvariant<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>* v )
{
    return v->index() == OFvariadic_find_type<T,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::value
    ?
        static_cast<T*>( v->content() )
    :
        OFnullptr
    ;
}

// The same as above, but for the const case.
template<typename T,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9,typename T10,typename T11,typename T12,typename T13,typename T14,typename T15,typename T16,typename T17,typename T18,typename T19,typename T20,typename T21,typename T22,typename T23,typename T24,typename T25,typename T26,typename T27,typename T28,typename T29,typename T30,typename T31,typename T32,typename T33,typename T34,typename T35,typename T36,typename T37,typename T38,typename T39,typename T40,typename T41,typename T42,typename T43,typename T44,typename T45,typename T46,typename T47,typename T48,typename T49>
const T* OFget( const OFvariant<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>* v )
{
    return v->index() == OFvariadic_find_type<T,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>::value
    ?
        static_cast<const T*>( v->content() )
    :
        OFnullptr
    ;
}

// Actual implementation if variant visitation.
template<typename ReturnType,typename FN,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9,typename T10,typename T11,typename T12,typename T13,typename T14,typename T15,typename T16,typename T17,typename T18,typename T19,typename T20,typename T21,typename T22,typename T23,typename T24,typename T25,typename T26,typename T27,typename T28,typename T29,typename T30,typename T31,typename T32,typename T33,typename T34,typename T35,typename T36,typename T37,typename T38,typename T39,typename T40,typename T41,typename T42,typename T43,typename T44,typename T45,typename T46,typename T47,typename T48,typename T49>
ReturnType OFvisit( FN fn, OFvariant<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>& v )
{
    return OFvariant_invoke<OFvariant_visit_invoker<ReturnType,FN>,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>( v.index(), v.content(), OFvariant_visit_invoker<ReturnType,FN>( fn ) );
}

// The same as above, but for the const case.
template<typename ReturnType,typename FN,typename T0,typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7,typename T8,typename T9,typename T10,typename T11,typename T12,typename T13,typename T14,typename T15,typename T16,typename T17,typename T18,typename T19,typename T20,typename T21,typename T22,typename T23,typename T24,typename T25,typename T26,typename T27,typename T28,typename T29,typename T30,typename T31,typename T32,typename T33,typename T34,typename T35,typename T36,typename T37,typename T38,typename T39,typename T40,typename T41,typename T42,typename T43,typename T44,typename T45,typename T46,typename T47,typename T48,typename T49>
ReturnType OFvisit( FN fn, const OFvariant<T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>& v )
{
    return OFvariant_invoke<OFvariant_const_visit_invoker<ReturnType,FN>,T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48,T49>( v.index(), v.content(), OFvariant_const_visit_invoker<ReturnType,FN>( fn ) );
}

#endif // !DOXYGEN

#endif // VARIADIC_VARIANT_H
